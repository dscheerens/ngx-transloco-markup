import { TranslationMarkupRenderer } from '../translation-markup-renderer.model';
import { TranslationMarkupTranspilerContext } from '../translation-markup-transpiler.model';

import { SubstitutionToken, SubstitutionTranspiler } from './substitution-transpiler';

class TestSubstitutionTranspiler extends SubstitutionTranspiler {
    protected createRenderer(): TranslationMarkupRenderer {
        return () => document.createComment('');
    }
}

function createTestTranspiler(token: string): TestSubstitutionTranspiler {
    return new TestSubstitutionTranspiler(token);
}

describe('SubstitutionTranspiler', () => {
    describe('tokenize function', () => {
        it('recognizes substitution tokens', () => {
            const testCases = [
                { token: '[x]', translation: 'x [X][x][x[]] x [x]', expectedTokenOffsets: [5, 16] },
                { token: '$xyz', translation: 'xyz$xy z$xzy$xyz$xyz', expectedTokenOffsets: [12, 16] },
                { token: '*', translation: '*!abc** ', expectedTokenOffsets: [0, 5, 6] },
            ];

            for (const { token, translation, expectedTokenOffsets } of testCases) {
                const transpiler = createTestTranspiler(token);

                for (const [offset] of translation.split('').entries()) {
                    const result = transpiler.tokenize(translation, offset);

                    if (expectedTokenOffsets.includes(offset)) {
                        expect(result).toBeDefined();
                        expect(result!.nextOffset).toBe(offset + token.length);
                        expect(result!.token).toBeInstanceOf(SubstitutionToken);
                        expect((result!.token as SubstitutionToken).token).toBe(token);
                    } else {
                        expect(result).toBeUndefined();
                    }
                }
            }
        });
    });

    describe('transpile function', () => {
        it('returns undefined for unknown tokens', () => {
            const transpiler = createTestTranspiler('{x}');
            const tokens = ['{', 'x', '}', '{x}', true, false, 4, undefined, { token: '{x}' }, ['{', 'x', '}']];
            const context = new TranslationMarkupTranspilerContext(tokens, {}, [transpiler]);

            for (const [offset] of tokens.entries()) {
                expect(transpiler.transpile(offset, context)).toBeUndefined();
            }
        });

        it('returns undefined for other substitution tokens', () => {
            const transpiler = createTestTranspiler('{x}');
            const tokens = ['{', 'x', '}', '{X}', '{ x }', '{z}'].map((token) => new SubstitutionToken(token));
            const context = new TranslationMarkupTranspilerContext(tokens, {}, [transpiler]);

            for (const [offset] of tokens.entries()) {
                expect(transpiler.transpile(offset, context)).toBeUndefined();
            }
        });

        it('transpiles supported substitution tokens', () => {
            const transpiler = createTestTranspiler('{x}');
            const tokens = [
                0,
                new SubstitutionToken('{x}'),
                new SubstitutionToken('{x}'),
                0,
                new SubstitutionToken('{x}'),
                new SubstitutionToken('{y}'),
                new SubstitutionToken('{}'),
                new SubstitutionToken('{x}'),
            ];
            const context = new TranslationMarkupTranspilerContext(tokens, {}, [transpiler]);

            const expectedResults = [0, 1, 1, 0, 1, 0, 0, 1];

            for (const [offset, expectedResult] of expectedResults.entries()) {
                const result = transpiler.transpile(offset, context);

                if (expectedResult === 0) {
                    expect(result).toBeUndefined();
                } else {
                    expect(result).toBeDefined();
                    expect(result!.nextOffset).toBe(offset + expectedResult);
                    expect(result!.renderer).toBeDefined();
                }
            }
        });

        it('transpiles tokens generated by its own tokenizer', () => {
            const transpiler = createTestTranspiler('?');
            const translation = 'abc?e??h';
            const tokens = Array.from(translation)
                .map((char) => transpiler.tokenize(char, 0))
                .map((result) => result?.token);
            const context = new TranslationMarkupTranspilerContext(tokens, {}, [transpiler]);

            const expectedResults = [0, 0, 0, 1, 0, 1, 1, 0];

            for (const [offset, expectedResult] of expectedResults.entries()) {
                const result = transpiler.transpile(offset, context);

                if (expectedResult === 0) {
                    expect(result).toBeUndefined();
                } else {
                    expect(result).toBeDefined();
                    expect(result!.nextOffset).toBe(offset + expectedResult);
                    expect(result!.renderer).toBeDefined();
                }
            }
        });
    });
});
